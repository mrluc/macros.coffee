<!DOCTYPE html>  <html> <head>   <title>macros.coffee</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>            <div id="jump_to">         Jump To &hellip;         <div id="jump_wrapper">           <div id="jump_page">                                           <a class="source" href="core_macros.html">                 core_macros.coffee               </a>                                           <a class="source" href="macros.html">                 macros.coffee               </a>                        </div>         </div>       </div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               macros.coffee             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>               <p><strong>macros.coffee</strong> is a stupid-simple implementation of Lisp-style macros for
CoffeeScript in 100 lines.</p>

<p>If you install macros.coffee, CoffeeScript will work normally, but it will
understand macro definitions of the form</p>

<pre><code>mac foo (ast) -&gt; transformed_ast
</code></pre>

<p>... and will automatically <em>macroexpand</em> them in coffeescript files that
contain the declaration <code>"use macros"</code>.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="p">[</span><span class="nx">G_COUNT</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">root</span><span class="p">]</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">,</span> <span class="nb">window</span> <span class="o">?</span> <span class="nx">global</span><span class="p">]</span>
<span class="p">[</span> <span class="nx">fs</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">CS</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dc</span> <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="k">for</span> <span class="nx">s</span> <span class="k">in</span> <span class="s">&#39;fs path coffee-script underscore owl-deepcopy&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">))</span></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <h3>Utility Functions</h3>

<p><code>gensym</code> gives names to variables in generated code.</p>

<p><code>nodewalk</code> walks the nodes of the tree returned by <code>CoffeeScript.nodes</code>.
Our visitor callback is handed a 'setter' function that can be used to
set the value of the current node; for instance,
<code>nodewalk CoffeeScript.nodes(codestring), (n,set)-&gt; set CoffeeScript.nodes "2"</code>
uses the setter function to replace the first node encountered with the number 2.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nv">gensym = </span><span class="nf">(s=&#39;&#39;)-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">s</span><span class="si">}</span><span class="s">_g</span><span class="si">#{</span><span class="o">++</span><span class="nx">G_COUNT</span><span class="si">}</span><span class="s">&quot;</span>

<span class="nv">nodewalk = </span><span class="nf">(n, visit, dad = undefined) -&gt;</span>
  <span class="k">return</span> <span class="nx">unless</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span>
  <span class="nv">dad = </span><span class="nx">n</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">expressions</span>
  <span class="k">for</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span>
    <span class="k">return</span> <span class="nx">unless</span> <span class="nv">kid = </span><span class="nx">n</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">kid</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="k">then</span> <span class="k">while</span> <span class="nx">kid</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="p">((</span><span class="o">++</span><span class="nx">i</span> <span class="k">if</span> <span class="nx">i</span><span class="o">?</span><span class="p">)</span> <span class="o">?</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="nx">visit</span> <span class="nx">kid</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="p">(</span><span class="nf">(node) -&gt;</span> <span class="nx">kid</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">),</span> <span class="nx">dad</span>
      <span class="nx">nodewalk</span> <span class="nx">kid</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">visit</span><span class="p">,</span> <span class="nx">dad</span>
    <span class="k">else</span>
      <span class="nx">visit</span> <span class="nx">kid</span><span class="p">,</span> <span class="p">(</span><span class="nf">(node)-&gt;</span> <span class="nv">kid = </span><span class="nx">n</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span><span class="p">),</span> <span class="nx">dad</span>
      <span class="nx">nodewalk</span> <span class="nx">kid</span><span class="p">,</span> <span class="nx">visit</span><span class="p">,</span> <span class="nx">dad</span>
  <span class="nx">n</span>

<span class="nv">isNode = </span><span class="nf">(o)-&gt;</span> <span class="nx">o</span><span class="p">.</span><span class="nx">isStatement</span><span class="o">?</span> <span class="o">or</span> <span class="nx">o</span><span class="p">.</span><span class="nx">compile</span><span class="o">?</span>
<span class="nv">isValue = </span><span class="nf">(o)-&gt;</span>
  <span class="k">for</span> <span class="nx">k</span> <span class="k">in</span> <span class="s">&#39;Number String Boolean RegExp Date Function&#39;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">yes</span> <span class="k">if</span> <span class="nx">_</span><span class="p">[</span><span class="s">&quot;is</span><span class="si">#{</span><span class="nx">k</span><span class="si">}</span><span class="s">&quot;</span><span class="p">](</span><span class="nx">o</span><span class="p">)</span>
  <span class="kc">no</span></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p><code>deepcopy</code> of the AST using OWL's wonderful deep copy implementation</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nv">deepcopy = </span><span class="nx">dc</span><span class="p">.</span><span class="nx">deepCopy</span></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p><code>backquote</code> takes a hash of values and a tree of nodes. For instance,
<code>backquote (a:2), quote -&gt; 2 + a</code> would produce <code>2 + 2</code>. Its definition
must be special-cased to recognize names in language features like comprehensions.
TODO: tests to see what language features are still not replaceable.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nv">backquote = bq = </span><span class="nf">(vs,ns) -&gt;</span>
  <span class="nv">get_name = </span><span class="nf">(n)-&gt;</span> <span class="nx">node_name</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">?</span> <span class="nx">n</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span>
  <span class="nv">val2node = </span><span class="nf">(val)-&gt;</span><span class="k">if</span> <span class="nx">isNode</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="k">then</span> <span class="nx">val</span> <span class="k">else</span> <span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">val</span><span class="si">}</span><span class="s">&quot;</span>
  <span class="nx">nodewalk</span> <span class="nx">ns</span><span class="p">,</span> <span class="nf">(n,set)-&gt;</span>
    <span class="nx">set</span> <span class="nx">val2node</span><span class="p">(</span><span class="nx">vs</span><span class="p">[</span><span class="nx">s</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="o">=</span><span class="nx">get_name</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">?</span>
    <span class="nv">n.name.value = </span><span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>          <span class="k">if</span> <span class="p">(</span><span class="nx">ss</span><span class="o">=</span><span class="nx">n</span><span class="p">.</span><span class="nx">name</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>  <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span> <span class="c1">#no .source allows .vars</span>
    <span class="nv">n.index.value = </span><span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>         <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">source</span><span class="o">?</span> <span class="o">and</span> <span class="p">(</span><span class="nx">ss</span><span class="o">=</span><span class="nx">n</span><span class="p">.</span><span class="nx">index</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>

<span class="nv">uses_macros = </span><span class="nf">(ns)-&gt;</span> <span class="nx">r</span><span class="o">=</span><span class="kc">no</span><span class="p">;</span> <span class="nx">nodewalk</span><span class="p">(</span><span class="nx">ns</span><span class="p">,</span><span class="nf">(n)-&gt;</span> <span class="nx">r</span><span class="o">=</span><span class="kc">yes</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="s">&quot;&#39;use macros&#39;&quot;</span><span class="p">);</span> <span class="nx">r</span>
<span class="nv">node_name = </span><span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">variable</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <h3>Instance Methods</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p>Our MacroScript instance provides the same API as the CoffeeScript require.
<code>eval</code>, <code>compile</code>, and <code>nodes</code> work about the same.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nv">exports.MacroScript = </span><span class="k">class</span> <span class="nx">MacroScript</span>

  <span class="nx">constructor</span><span class="o">:</span><span class="nf">(@macros={},@types=[name:&#39;mac&#39;,recognize:node_name],@strict=no,@opts=bare:on)-&gt;</span>

  <span class="nb">eval</span><span class="o">:</span> <span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">strict</span><span class="o">=</span><span class="nx">@strict</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">eval</span> <span class="nx">@compile</span> <span class="nx">s</span><span class="p">,</span><span class="nx">@opts</span><span class="p">,</span><span class="nx">strict</span>

  <span class="nv">compile: </span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">opts</span><span class="o">=</span><span class="nx">@opts</span><span class="p">,</span> <span class="nx">strict</span><span class="o">=</span><span class="nx">@strict</span><span class="p">)</span><span class="o">=&gt;</span>
    <span class="nx">@nodes</span> <span class="p">(</span><span class="nx">s</span> <span class="o">?</span> <span class="s">&#39;&#39;</span><span class="p">),</span> <span class="nx">strict</span>
    <span class="nx">@compile_lint</span> <span class="nx">@ast</span><span class="p">,</span> <span class="nx">opts</span>

  <span class="nv">compile_lint: </span><span class="nf">(n,opts=@opts)-&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">opts</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/undefined/g</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p><code>nodes</code> is a high-level description of the implementation:
We get the AST from CoffeeScript, find and compile any macro definitions
it may contain, and then expand any calls to those macros that may exist.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">nodes: </span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">strict</span><span class="o">=</span><span class="nx">@strict</span><span class="p">)</span><span class="o">=&gt;</span>
    <span class="vi">@ast = </span><span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span> <span class="nx">str</span>
    <span class="k">if</span> <span class="o">!</span><span class="nx">strict</span> <span class="o">or</span> <span class="nx">uses_macros</span><span class="p">(</span><span class="nx">@ast</span><span class="p">)</span>
      <span class="nx">@find_and_compile_macros</span><span class="p">()</span>
      <span class="nx">@macroexpand</span><span class="p">()</span> <span class="nx">until</span> <span class="nx">@all_expanded</span><span class="p">()</span>
    <span class="nx">@ast</span></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p><code>find_and_compile_macros</code> expands and compiles macro definitions, and
calls from within those definitions. (It doesn't touch anything outside
of macro <em>definitions</em>, however).
By default, it can recognize names of function calls that looks like this:
<code>mac foo (n)-&gt; n</code>; that is to say,
<code>macroSignifier( nameOfMacro( definitionOfMacroAsFunction) )</code>.
We store the nodes of that macro, and a function to recognize it,
under the name recognized from its first argument.
Replace the macro definition with a comment.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">find_and_compile_macros: </span><span class="o">=&gt;</span>

    <span class="nx">nodewalk</span> <span class="nx">@ast</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">set</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="k">for</span> <span class="p">{</span><span class="nx">name</span><span class="p">,</span> <span class="nx">recognize</span><span class="p">}</span> <span class="k">in</span> <span class="nx">@types</span> <span class="k">when</span> <span class="nx">name</span> <span class="o">is</span> <span class="nx">recognize</span> <span class="nx">n</span>
        <span class="nv">name = </span><span class="nx">recognize</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">@macros</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span>
          <span class="nv">nodes: </span><span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="nv">recognize: </span><span class="nf">(n)-&gt;</span>  <span class="nx">name</span> <span class="k">if</span> <span class="nx">name</span> <span class="o">is</span> <span class="nx">recognize</span> <span class="nx">n</span>
          <span class="nv">compiled: </span><span class="kc">undefined</span>
        <span class="nx">set</span> <span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span> <span class="s">&quot;`//</span><span class="si">#{</span><span class="nx">name</span><span class="si">}</span><span class="s"> defined`&quot;</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p>The macro definitions are <strong>compiled</strong>, taking care to do it in the right
order, since they might rely on other macros.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">until</span> <span class="nx">@all_compiled</span><span class="p">()</span>
      <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="p">{</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">compiled</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="o">not</span> <span class="nx">compiled</span>
        <span class="k">if</span> <span class="nx">@calls_only_compiled</span> <span class="nx">nodes</span>
          <span class="nv">js = </span><span class="nx">@compile_lint</span> <span class="nx">@macroexpand</span> <span class="nx">nodes</span>
          <span class="nx">@macros</span><span class="p">[</span><span class="nx">name</span><span class="p">].</span><span class="nv">compiled = </span><span class="nb">eval</span> <span class="s">&quot;(</span><span class="si">#{</span><span class="nx">js</span><span class="si">}</span><span class="s">)&quot;</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p>Once the macros are all compiled, the logic
for macroexpansion is simple: if a node is recognized as a macro call,
then transform it with that macro's compiled definition.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">macroexpand: </span><span class="p">(</span><span class="nx">ns</span><span class="o">=</span><span class="nx">@ast</span><span class="p">)</span><span class="o">=&gt;</span>
    <span class="nv">expander = </span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">set</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span><span class="o">=&gt;</span>
      <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="p">{</span><span class="nx">recognize</span><span class="p">,</span> <span class="nx">compiled</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="nx">recognize</span> <span class="nx">n</span>
        <span class="nx">set</span> <span class="nx">compiled</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">parent</span><span class="p">,</span> <span class="nx">@</span><span class="p">)</span>
        <span class="nx">@find_and_compile_macros</span><span class="p">()</span> <span class="c1"># this buys us macro-defining macros.</span>
    <span class="nx">nodewalk</span> <span class="nx">ns</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">ns</span>

  <span class="nv">all_compiled: </span><span class="o">=&gt;</span>
    <span class="k">return</span> <span class="kc">no</span> <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="p">{</span><span class="nx">compiled</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="o">not</span> <span class="nx">compiled</span>
    <span class="kc">yes</span>

  <span class="nv">all_expanded: </span><span class="p">(</span><span class="nx">ast</span><span class="o">=</span><span class="nx">@ast</span><span class="p">,</span> <span class="nv">iz = </span><span class="kc">yes</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="k">return</span> <span class="kc">no</span> <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="p">{</span><span class="nx">recognize</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="nx">recognize</span> <span class="nx">@ast</span>
    <span class="nx">nodewalk</span> <span class="nx">ast</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nv">iz = </span><span class="kc">no</span> <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="p">{</span><span class="nx">recognize</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="nx">recognize</span> <span class="nx">n</span>
    <span class="nx">iz</span>

  <span class="nv">calls_only_compiled: </span><span class="p">(</span><span class="nx">ast</span><span class="o">=</span><span class="nx">@ast</span><span class="p">,</span> <span class="nv">does = </span><span class="kc">yes</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">nodewalk</span> <span class="nx">ast</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nv">does = </span><span class="kc">no</span> <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="p">{</span><span class="nx">compiled</span><span class="p">,</span> <span class="nx">recognize</span><span class="p">}</span> <span class="k">of</span> <span class="nx">@macros</span> <span class="k">when</span> <span class="o">!</span><span class="nx">compiled</span> <span class="o">and</span> <span class="nx">recognize</span> <span class="nx">n</span>
    <span class="nx">does</span></pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <h1>Usage</h1>

<p>As with CoffeeScript, you can either require CoffeeScript files (that use macros) directly,
or you can expand+compile files to Javascript and run that.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p>Simply <code>require 'module_using_macros'</code> should work,</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nx">exports</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">=</span><span class="nx">v</span> <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="k">of</span> <span class="k">new</span> <span class="nx">MacroScript</span>
<span class="nx">require</span><span class="p">.</span><span class="nx">extensions</span><span class="p">[</span><span class="s">&#39;.coffee&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nf">(module, fname) -&gt;</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">_compile</span> <span class="nx">exports</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">fname</span><span class="p">,</span> <span class="s">&#39;utf-8&#39;</span><span class="p">),</span><span class="nx">exports</span><span class="p">.</span><span class="nx">opts</span><span class="p">,</span> <span class="kc">yes</span><span class="p">),</span> <span class="nx">fname</span></pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>but be aware that command-line compiling is limited; the order
that files containing macros are compiled in will matter. And, since
CoffeeScript doesn't ship with an easy way to hook its command-line
compilation, this implementation takes the easy way out and doesn't
support specifying an output directory; the compiled javascript is
always written into the same location as the coffeescript. TODO:
bloops, the command-line check needs to see if the first argument
is 'our' name.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">if</span> <span class="nx">module</span><span class="p">.</span><span class="nx">filename</span> <span class="o">is</span> <span class="nx">process</span><span class="p">.</span><span class="nx">mainModule</span><span class="p">.</span><span class="nx">filename</span> <span class="o">and</span> <span class="nv">names = </span><span class="nx">process</span><span class="o">?</span><span class="p">.</span><span class="nx">argv</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="k">for</span> <span class="nx">src</span> <span class="k">in</span> <span class="nx">names</span>
    <span class="nx">p</span> <span class="nx">src</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span> <span class="nx">src</span><span class="p">,</span> <span class="s">&quot;utf-8&quot;</span><span class="p">,</span> <span class="nf">(err, code) -&gt;</span>
      <span class="k">throw</span> <span class="nx">err</span> <span class="k">if</span> <span class="nx">err</span>
      <span class="nv">name = </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span>
      <span class="nv">dir  = </span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">dirname</span><span class="p">(</span><span class="nx">src</span><span class="p">),</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">name</span><span class="si">}</span><span class="s">.js&quot;</span><span class="p">)</span>
      <span class="nv">out  = </span><span class="nx">exports</span><span class="p">.</span><span class="nx">compile</span> <span class="nx">code</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFile</span> <span class="nx">dir</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nf">(err)-&gt;</span> <span class="k">if</span> <span class="nx">err</span> <span class="k">then</span> <span class="k">throw</span> <span class="nx">err</span> <span class="k">else</span> <span class="nx">p</span> <span class="s">&quot;Success!&quot;</span>

</pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 