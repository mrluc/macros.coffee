<!DOCTYPE html>  <html> <head>   <title>macros.coffee</title>   <meta http-equiv="content-type" content="text/html; charset=UTF-8">   <link rel="stylesheet" media="all" href="docco.css" /> </head> <body>   <div id="container">     <div id="background"></div>          <table cellpadding="0" cellspacing="0">       <thead>         <tr>           <th class="docs">             <h1>               macros.coffee             </h1>           </th>           <th class="code">           </th>         </tr>       </thead>       <tbody>                               <tr id="section-1">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-1">&#182;</a>               </div>                            </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-2">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-2">&#182;</a>               </div>               <p><strong>macros.coffee</strong> is a 100-line prototype of Lisp-style macros in CoffeeScript.</p>

<h3>Why CoffeeScript?</h3>

<ol>
<li><p>CoffeeScript is a small language that only compiles down to Javascript,
not a VM, so its AST is pretty easy to work with.</p></li>
<li><p>Plus, CoffeeScript has a really flexible syntax, which you need for macros to
look like anything.</p></li>
<li><p>Too, JavaScript's metaprogramming is largely limited to tricks with <code>this</code>,
so the abilities macros offer are correspondingly more attractive.</p></li>
</ol>

<h3>How This Code Is Organized</h3>

<p>It's one class, plus a bunch of supporting functions.</p>

<p>The class <code>Macros</code> acts like the CoffeeScript
object; it relies on a number of supporting functions for AST
trickery. It doesn't do anything to CoffeeScript's lexer/parser,
or use CoffeeScript internals.</p>

<p>Also, it's written kind of densely ... a little code-golfed, to be honest.
I'm sorry -- 100 lines sounds like a nice, round number.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-3">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-3">&#182;</a>               </div>               <p>We use Underscore.js for type recognition and shallow copy. In browser ...</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">if</span> <span class="nb">window</span><span class="o">?</span> <span class="k">then</span> <span class="p">[</span> <span class="nx">root</span><span class="p">,</span> <span class="nx">_</span> <span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">window</span><span class="p">,</span> <span class="nb">window</span><span class="p">.</span><span class="nx">_</span> <span class="p">]</span></pre></div>             </td>           </tr>                               <tr id="section-4">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-4">&#182;</a>               </div>               <p>... or node.js</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">else</span> <span class="p">[</span> <span class="p">(</span><span class="nv">root = </span><span class="k">this</span><span class="p">).</span><span class="nx">CoffeeScript</span><span class="p">,</span> <span class="nx">_</span> <span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;coffee-script&#39;</span><span class="p">),</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;underscore&#39;</span><span class="p">)</span> <span class="p">]</span>

<span class="nv">G_COUNT = </span><span class="mi">0</span> <span class="c1"># Gensym Counter</span></pre></div>             </td>           </tr>                               <tr id="section-5">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-5">&#182;</a>               </div>               <h1>Utility Functions</h1>

<p>We need a whole library of functions to make transforming the AST easier. This
isn't that library; it'd be easier to write them once we have macros, anyhow.</p>

<p>These are just some functions that
mangle the AST <em>just</em> enough to get us macros.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="nv">Utils =</span></pre></div>             </td>           </tr>                               <tr id="section-6">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-6">&#182;</a>               </div>               <p><strong>nodewalk</strong>  walks the nodes of the AST. <code>nodewalk node, (n,set)-&gt; set CS.nodes 2</code>
replaces every node encountered with a 2. Which means that the whole node tree
would get replaced with a 2, as once the root node turns into a 2, there are no
children to walk.</p>

<p><code>nodewalk</code> started life as the David Padbury's <code>replacingWalk</code>,
and is the workhorse behind macroexpansion and backquotes.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">nodewalk: </span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">visitor</span><span class="p">,</span> <span class="nx">parent</span><span class="o">=</span><span class="kc">undefined</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="c1"># from d.padbury&#39;s replacingWalk.</span>
    <span class="k">return</span> <span class="nx">unless</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span>
    <span class="nv">parent = </span><span class="nx">node</span> <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">expressions</span>   <span class="c1"># TODO: parent if: 1. toplevel, or 2. is a fn.body</span>
    <span class="k">for</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span>
      <span class="k">return</span> <span class="k">if</span> <span class="o">!</span><span class="p">(</span><span class="nv">child = </span><span class="nx">node</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span>
      <span class="k">if</span> <span class="nx">child</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="k">then</span> <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="nx">i</span> <span class="k">if</span> <span class="nx">i</span><span class="o">?</span><span class="p">)</span> <span class="o">?</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">child</span><span class="p">.</span><span class="nx">length</span>
        <span class="nx">visitor</span> <span class="nx">child</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="p">(</span><span class="nf">(newval) -&gt;</span> <span class="nx">child</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newval</span><span class="p">),</span> <span class="nx">parent</span>
        <span class="nx">nodewalk</span> <span class="nx">child</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">visitor</span><span class="p">,</span> <span class="nx">parent</span>
      <span class="k">else</span>
        <span class="nx">visitor</span> <span class="nx">child</span><span class="p">,</span> <span class="p">(</span><span class="nf">(newval) -&gt;</span> <span class="nv">child = </span><span class="nx">node</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newval</span><span class="p">),</span> <span class="nx">parent</span>
        <span class="nx">nodewalk</span> <span class="nx">child</span><span class="p">,</span> <span class="nx">visitor</span><span class="p">,</span> <span class="nx">parent</span></pre></div>             </td>           </tr>                               <tr id="section-7">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-7">&#182;</a>               </div>               <p><strong>deepcopy</strong> is important for macros. To <code>quote</code> a tree of source code for use as a template,
you need to deep copy it, or you'll get hilarious shared-structure bugs.
This is a naive implementation that recursively shallow-copies with <code>_.clone</code>.
It's doesn't handle circular objects, just the kind of 'tree of values' that makes up an AST.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">deepcopy: </span><span class="nf">(o)-&gt;</span>
    <span class="k">throw</span> <span class="s2">&quot;No underscore?!?&quot;</span> <span class="nx">unless</span> <span class="nx">_</span> <span class="o">and</span> <span class="nx">_</span><span class="p">.</span><span class="nx">clone</span>
    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span> <span class="k">of</span> <span class="p">(</span><span class="nx">o2</span><span class="o">=</span><span class="nx">_</span><span class="p">.</span><span class="nx">clone</span> <span class="nx">o</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">or</span> <span class="k">typeof</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;object&#39;</span><span class="p">)</span> <span class="o">and</span> <span class="o">!</span><span class="p">(</span><span class="nx">is_value</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">or</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
        <span class="k">try</span> <span class="p">(</span><span class="nx">o2</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">deepcopy</span> <span class="nx">v</span> <span class="k">if</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">v</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">catch</span> <span class="nx">e</span> <span class="k">then</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="p">[</span><span class="nx">e</span><span class="p">,</span> <span class="nx">v</span><span class="p">]</span>
    <span class="nx">o2</span></pre></div>             </td>           </tr>                               <tr id="section-8">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-8">&#182;</a>               </div>               <p><strong>is_value</strong> is used by deepcopy, and delegates to Underscore.js to detect types.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">is_value: </span> <span class="nf">(o)-&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">or</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isString</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">or</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isBoolean</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">or</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isRegExp</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="o">or</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isDate</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-9">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-9">&#182;</a>               </div>               <p><strong>backquote</strong> is the workhorse behind the return value of most macros.
Given a hash of <code>v</code>alue<code>s</code> and a(n AST)ree of <code>n</code>ode<code>s</code>, like so:</p>

<pre><code>backquote { my_var: 3, my_other_var: quote -&gt; 2+2 }, quote -&gt;
  x = my_var
  y = my_other_var
</code></pre>

<p>backquote will walk the nodes of that AST, making the substitutions
found in the values hash, and returns the transformed tree. The
logic has to be special-cased to recognize and set various language features,
like variable assignment, or the name/index fields in a list comprehension,
and it doesn't support them all yet.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">backquote: </span><span class="nf">(vs,ns) -&gt;</span>
    <span class="nx">nodewalk</span> <span class="nx">ns</span><span class="p">,</span> <span class="nf">(n,set)-&gt;</span>
      <span class="nx">set</span> <span class="nx">val2node</span><span class="p">(</span><span class="nx">vs</span><span class="p">[</span><span class="nx">s</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="o">=</span><span class="nx">get_name</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">?</span>
      <span class="p">(</span><span class="nv">n.variable.base.value = </span><span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">];</span> <span class="nx">set</span> <span class="nx">n</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ss</span><span class="o">=</span><span class="nx">n</span><span class="p">.</span><span class="nx">variable</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>      <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>
      <span class="p">(</span><span class="nv">n.name.value = </span><span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">];</span> <span class="nx">set</span> <span class="nx">n</span><span class="p">)</span>          <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">source</span><span class="o">?</span> <span class="o">and</span> <span class="p">(</span><span class="nx">ss</span><span class="o">=</span><span class="nx">n</span><span class="p">.</span><span class="nx">name</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>  <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>
      <span class="p">(</span><span class="nv">n.index.value = </span><span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">];</span> <span class="nx">set</span> <span class="nx">n</span><span class="p">)</span>         <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">source</span><span class="o">?</span> <span class="o">and</span> <span class="p">(</span><span class="nx">ss</span><span class="o">=</span><span class="nx">n</span><span class="p">.</span><span class="nx">index</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span> <span class="o">and</span> <span class="nx">vs</span><span class="p">[</span><span class="nx">ss</span><span class="p">]</span>
    <span class="nx">ns</span>
  <span class="nv">bq: </span><span class="nf">(args, nodes) -&gt;</span> <span class="nx">backquote</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">nodes</span>   <span class="c1"># Alias for backquote.</span></pre></div>             </td>           </tr>                               <tr id="section-10">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-10">&#182;</a>               </div>               <p><strong>val2node</strong> is called by <code>backquote</code> on values to be spliced in.
If something's not a node yet (like a string or number) this turns it into one.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">val2node: </span><span class="nf">(v)-&gt;</span><span class="k">if</span> <span class="nx">is_node</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="k">then</span> <span class="nx">v</span> <span class="k">else</span> <span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span> <span class="s2">&quot;#{v}&quot;</span></pre></div>             </td>           </tr>                               <tr id="section-11">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-11">&#182;</a>               </div>               <p><strong>gensym</strong>s are generated symbols with unique names, used to avoid name clashes
in generated code. There are no symbols in Java/CoffeeScript, but we still need
generated variable names.</p>

<p>These aren't guaranteed unique, but if you don't normally
add <code>_g207</code> to your variable names it'll work for our macros.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">gensym: </span><span class="nf">(s)-&gt;</span> <span class="s2">&quot;#{s ? s or &#39;&#39;}_g#{++G_COUNT}&quot;</span></pre></div>             </td>           </tr>                               <tr id="section-12">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-12">&#182;</a>               </div>               <p><strong>argschain</strong> is a helper for down-and-dirty DSL macros that may
want to abuse function-call syntax.</p>

<p>In CoffeeScript, like Ruby and other languages,
<code>a b c d</code> means <code>a(b(c(d)))</code>. That nesting can be a pain; in Lisp,
sequences have the same syntax as function calls, so it's a non-issue.
<code>argschain quote -&gt; a b c d, e b g (100) 123</code> returns nodes in an
array, like <code>[a,b,c,[d,e],b,g,(100),123]</code></p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">argschain: </span><span class="nf">(n,acc=[]) -&gt;</span>
    <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span> <span class="nx">n</span> <span class="k">if</span> <span class="nx">acc</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="o">?</span><span class="p">.</span><span class="nx">length</span>
      <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">then</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span> <span class="p">)</span>
      <span class="nx">argschain</span><span class="p">(</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">acc</span> <span class="p">)</span>
    <span class="k">else</span> <span class="nx">acc</span></pre></div>             </td>           </tr>                               <tr id="section-13">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-13">&#182;</a>               </div>               <p>Some shortcuts for checking properties of nodes,
mostly copy-pasted from the Repl.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">n_index: </span><span class="nf">(node, p) -&gt;</span> <span class="c1"># index of node in expressions array of parent/undefined.</span>
    <span class="p">(</span><span class="k">return</span> <span class="nx">i</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">contains</span><span class="o">?</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">contains</span><span class="p">(</span><span class="nf">(nu)-&gt;</span><span class="nx">nu</span> <span class="o">is</span> <span class="nx">node</span><span class="p">))</span> <span class="k">for</span> <span class="nx">n</span><span class="p">,</span><span class="nx">i</span> <span class="k">in</span> <span class="nx">p</span><span class="p">.</span><span class="nx">expressions</span>
    <span class="kc">undefined</span>
  <span class="nv">n_last: </span>                 <span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">expressions</span><span class="o">?</span><span class="p">[</span><span class="nx">n</span><span class="p">.</span><span class="nx">expressions</span><span class="o">?</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nx">n</span>
  <span class="nv">n_is_in: </span>                <span class="nf">(n,parent) -&gt;</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">contains</span> <span class="nf">(k) -&gt;</span> <span class="nx">k</span> <span class="o">is</span> <span class="nx">n</span>
  <span class="nv">n_is_last: </span>              <span class="nf">(n,parent)-&gt;</span>  <span class="nx">n_last</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span> <span class="o">is</span> <span class="nx">n</span></pre></div>             </td>           </tr>                               <tr id="section-14">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-14">&#182;</a>               </div>               <p>We use this to wrap up a chained check into some of the common places
that a node might store its 'name' -- a name, a value, or a value wrapped in a block.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">get_name: </span>               <span class="nf">(n)-&gt;</span> <span class="nx">node_name</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">?</span> <span class="nx">values</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">?</span> <span class="nx">simple_expression_value</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
  <span class="nv">simple_expression_value: </span><span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">variable</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">body</span><span class="o">?</span><span class="p">.</span><span class="nx">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span>
  <span class="nv">strip_expression: </span>       <span class="nf">(n)-&gt;</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">expressions</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">?</span> <span class="k">then</span> <span class="nx">n</span><span class="p">.</span><span class="nx">expressions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="nx">n</span></pre></div>             </td>           </tr>                               <tr id="section-15">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-15">&#182;</a>               </div>               <p>This is the one we use to identify macro names.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">node_name: </span>              <span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">variable</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span>
  <span class="nv">values: </span>                 <span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">base</span><span class="o">?</span><span class="p">.</span><span class="nx">value</span>
  <span class="nv">variable: </span>               <span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">variable</span>
  <span class="nv">is_node: </span>                <span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">isStatement</span><span class="o">?</span> <span class="o">or</span> <span class="nx">n</span><span class="o">?</span><span class="p">.</span><span class="nx">compile</span><span class="o">?</span>
  <span class="nv">arguments: </span><span class="kc">undefined</span> <span class="c1"># Monkeypatch weirdness in some browsers,</span>
  <span class="nv">CS: </span>       <span class="nx">root</span><span class="p">.</span><span class="nx">CoffeeScript</span> <span class="c1"># alias the CoffeeScript object,</span>
  <span class="nv">keys: </span>     <span class="nf">(o)-&gt;</span> <span class="nx">k</span> <span class="k">for</span> <span class="nx">own</span> <span class="nx">k</span> <span class="k">of</span> <span class="nx">o</span>
  <span class="nv">propmost: </span><span class="nf">(n,k=&#39;first&#39;)-&gt;</span> <span class="k">if</span> <span class="nx">n</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span><span class="o">?</span> <span class="o">and</span> <span class="nx">n</span><span class="p">[</span><span class="nx">k</span><span class="p">][</span><span class="nx">k</span><span class="p">]</span><span class="o">?</span> <span class="k">then</span> <span class="nx">propmost</span><span class="p">(</span><span class="nx">n</span><span class="p">[</span><span class="nx">k</span><span class="p">],</span> <span class="nx">k</span><span class="p">)</span> <span class="k">else</span> <span class="nx">n</span></pre></div>             </td>           </tr>                               <tr id="section-16">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-16">&#182;</a>               </div>               <h1>Macro Object</h1>

<p>An instance of Macro will behave like the CoffeeScript object,
 with <code>.nodes</code>, <code>.compile</code>, <code>.run</code>.</p>

<h3>API</h3>

<p><code>compile</code> and <code>run</code> result in complete macroexpansion and compilation
of the code string passed in.</p>

<p><code>nodes</code>, <code>macex</code>, and <code>ex1</code> results in differing levels of macroexpansion,
if you want to gander at the AST more closely -- use <code>nodes</code> to see
it after macro <em>definitions</em> have been expanded, and <code>macex</code> to see
it after more complete macroexpansion. Or perform a single, targetted
expansion with <code>ex1</code>.</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">class</span> <span class="nx">Macro</span></pre></div>             </td>           </tr>                               <tr id="section-17">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-17">&#182;</a>               </div>               <h3>Setup &amp; Constructor</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-18">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-18">&#182;</a>               </div>               <p>Monkey-include those functions, above, into scope.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;#{k} = Utils[&#39;#{k}&#39;]&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="nx">own</span> <span class="nx">k</span> <span class="k">of</span> <span class="nx">Utils</span></pre></div>             </td>           </tr>                               <tr id="section-19">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-19">&#182;</a>               </div>               <p>Cleanup; <code>undefined</code> shows up in indented code;
we're apparently nuking indent info somewhere. TODO.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">compile_lint = </span><span class="nf">(n)-&gt;</span> <span class="nx">n</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span><span class="nx">bare</span><span class="o">:</span><span class="kc">on</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/undefined/g</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-20">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-20">&#182;</a>               </div>               <p>Pass a string of code to the constructor, and it gets sent
right to <code>.nodes</code>. <code>nodes</code> is probably the most important
function in the implementation.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">constructor: </span><span class="nf">(str=&#39; &#39;,@macs={}, @macnodes={})-&gt;</span> <span class="nx">@nodes</span> <span class="nx">str</span></pre></div>             </td>           </tr>                               <tr id="section-21">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-21">&#182;</a>               </div>               <h3>Implementation</h3>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-22">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-22">&#182;</a>               </div>               <p><strong>nodes</strong> calls
<code>CoffeeScript.nodes</code>, but then does two other things: it <em>finds and saves</em>
macro definitions, and then <em>macroexpands and compiles</em>
them for later use.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">nodes: </span><span class="p">(</span><span class="nx">str</span><span class="p">)</span><span class="o">=&gt;</span></pre></div>             </td>           </tr>                               <tr id="section-23">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-23">&#182;</a>               </div>               <p>It does this by walking the AST and copying out anything that looks like a
macro definition, saving it into <code>macnodes</code> under its name.
For <code>mac foo (n)-&gt; ...</code>, the expansion of
<code>(n)-&gt;...</code> would be saved into <code>@macnodes['foo']</code>,
and replaced with a comment in the output.</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">nodewalk</span> <span class="p">(</span><span class="vi">@input = </span><span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span> <span class="nx">str</span><span class="p">),</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">set</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="k">if</span> <span class="nx">node_name</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">is</span> <span class="s1">&#39;mac&#39;</span>
        <span class="nx">@macnodes</span><span class="p">[</span> <span class="nv">name = </span><span class="nx">node_name</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">]</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">set</span> <span class="nx">CS</span><span class="p">.</span><span class="nx">nodes</span><span class="p">(</span><span class="s2">&quot;/* mac &#39;#{name}&#39; defined  */&quot;</span><span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-24">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-24">&#182;</a>               </div>               <p>Next, it loops through uncompiled macro definitions, expanding and compiling.
This must be done in the right order; macros often use <em>other</em> macros!
So for each of the macro definitions that's not compiled yet,</p>             </td>             <td class="code">               <div class="highlight"><pre>    <span class="nx">until</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">@macnodes</span><span class="p">).</span><span class="nx">length</span> <span class="o">&lt;=</span> <span class="nx">keys</span><span class="p">(</span><span class="nx">@macs</span><span class="p">).</span><span class="nx">length</span>
      <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">@macnodes</span> <span class="k">when</span> <span class="nx">is_node</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">and</span> <span class="o">!</span><span class="nx">@macs</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">and</span> <span class="nx">doit</span><span class="o">=</span><span class="kc">on</span></pre></div>             </td>           </tr>                               <tr id="section-25">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-25">&#182;</a>               </div>               <p>if the definition <em>doesn't</em> call an <em>uncompiled</em> macro,</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="nx">nodewalk</span> <span class="nx">v</span><span class="p">,(</span><span class="nx">n</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">doit</span><span class="o">=</span><span class="kc">no</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="o">=</span><span class="nx">node_name</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="nx">@macnodes</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">@macs</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">?</span></pre></div>             </td>           </tr>                               <tr id="section-26">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-26">&#182;</a>               </div>               <p>then macroexpansion will work! Expand,
compile and evaluate the definition, and save
the result in <code>@macs</code> under the macro name.</p>             </td>             <td class="code">               <div class="highlight"><pre>        <span class="nx">@macex</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="o">and</span> <span class="nx">@macs</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">eval</span> <span class="s2">&quot;(#{compile_lint v})&quot;</span> <span class="k">if</span> <span class="nx">doit</span>
    <span class="nx">@input</span></pre></div>             </td>           </tr>                               <tr id="section-27">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-27">&#182;</a>               </div>               <p><strong>macex</strong> expands <em>all</em> macro calls, not just those in macro definitions.
Given nodes, it looks for a call against a function with
a macro's name. It sends those nodes to be processed by the associated
macro, performing a single macroexpansion via <code>ex1</code>.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">macex: </span><span class="p">(</span><span class="nx">ns</span><span class="o">=</span><span class="nx">@input</span><span class="p">)</span> <span class="o">=&gt;</span>
    <span class="nx">nodewalk</span> <span class="nx">ns</span><span class="p">,((</span><span class="nx">n</span><span class="p">,</span><span class="nx">set</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">set</span> <span class="nx">@ex1</span> <span class="nx">s</span><span class="p">,</span><span class="nx">n</span><span class="p">,</span><span class="nx">p</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="o">=</span><span class="nx">node_name</span> <span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">@macs</span><span class="p">[</span><span class="nx">s</span><span class="p">]</span><span class="o">?</span><span class="p">),</span> <span class="nx">ns</span></pre></div>             </td>           </tr>                               <tr id="section-28">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-28">&#182;</a>               </div>               <p><strong>ex1</strong> perform a single macroexpansion. Given a macro name, a node, and its parent,
call the macro stored with that name, passing the node and the node whose
<code>expressions</code> array contains it.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">ex1: </span><span class="p">(</span><span class="nx">macro</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">@macs</span><span class="p">[</span><span class="nx">macro</span><span class="p">](</span><span class="nx">node</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-29">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-29">&#182;</a>               </div>               <p>The order of expansion means <code>macex</code> need only be run once. Probably.
But just in case, <strong>macex_done</strong> can be used to test whether or not a code tree
contains un-expanded macro calls.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">macex_done: </span><span class="p">(</span><span class="nx">nodes</span><span class="o">=</span><span class="nx">@input</span><span class="p">,</span> <span class="nx">done</span><span class="o">=</span><span class="kc">yes</span><span class="p">)</span><span class="o">=&gt;</span>
    <span class="nx">nodewalk</span> <span class="nx">nodes</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nx">done</span><span class="o">=</span><span class="kc">no</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span><span class="o">=</span><span class="nx">node_name</span> <span class="nx">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">@macs</span>
    <span class="nx">done</span></pre></div>             </td>           </tr>                               <tr id="section-30">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-30">&#182;</a>               </div>               <p><strong>compile</strong>, like CoffeeScript's compile, outputs javascript.
It calls <code>nodes</code>, which takes care of any macro <em>definitions</em> it
may contain, performs macroexpansion on the AST via <code>macex</code>,
and spits out compiled javascript.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">compile: </span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">=&gt;</span>
    <span class="nx">@nodes</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="k">if</span> <span class="nx">s</span>
    <span class="nx">@macex</span><span class="p">()</span> <span class="nx">until</span> <span class="nx">@macex_done</span><span class="p">()</span>
    <span class="nx">compile_lint</span> <span class="nx">@input</span></pre></div>             </td>           </tr>                               <tr id="section-31">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-31">&#182;</a>               </div>               <p>Like the CoffeeScript object, <code>run</code> uses <code>eval</code> to
execute <code>compile</code>d code immediately.</p>             </td>             <td class="code">               <div class="highlight"><pre>  <span class="nv">run: </span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">=&gt;</span> <span class="nb">eval</span><span class="p">(</span> <span class="k">if</span> <span class="nx">s</span><span class="o">?</span> <span class="k">then</span> <span class="nx">@compile</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="k">else</span> <span class="nx">@compile</span><span class="p">()</span> <span class="p">)</span></pre></div>             </td>           </tr>                               <tr id="section-32">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-32">&#182;</a>               </div>               <h1>Using From Node.js</h1>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-33">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-33">&#182;</a>               </div>               <p>In a Node.js environment, this file functions as a
basic preprocessor. Call it like this:</p>

<pre><code>coffee macros.coffee file1.coffee file2.coffee ...
</code></pre>

<p>Or like this:</p>

<pre><code>coffee macros.coffee dir/*.coffee
</code></pre>

<p>And it will kick out a macro-expanded, compiled-to-javascript
version of those coffee files.</p>

<p>There's no support for specifying an output directory yet.
But what do you want? Egg in your suds?</p>             </td>             <td class="code">               <div class="highlight"><pre><span class="k">if</span> <span class="nx">process</span><span class="o">?</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nv">ns = </span><span class="nx">process</span><span class="o">?</span><span class="p">.</span><span class="nx">argv</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">and</span> <span class="nv">ns = </span><span class="nx">ns</span><span class="p">[</span><span class="mi">2</span><span class="p">..</span><span class="nx">ns</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="c1">#1st 2 are</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s2">&quot;Processing from the command line: #{ns}&quot;</span>
  <span class="p">[</span><span class="nx">fs</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">_</span><span class="p">]</span>    <span class="o">=</span> <span class="p">(</span><span class="nx">require</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="k">for</span> <span class="nx">s</span> <span class="k">in</span> <span class="p">[</span><span class="s1">&#39;fs&#39;</span><span class="p">,</span><span class="s1">&#39;path&#39;</span><span class="p">,</span><span class="s1">&#39;underscore&#39;</span><span class="p">])</span>
  <span class="p">[</span><span class="nx">p</span><span class="p">,</span> <span class="nx">MacroScript</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">,</span> <span class="p">(</span><span class="k">new</span> <span class="nx">Macro</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span>
  <span class="k">for</span> <span class="nx">src</span> <span class="k">in</span> <span class="nx">ns</span>
    <span class="nx">p</span> <span class="nx">src</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span> <span class="nx">src</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="nf">(err, code) -&gt;</span>
      <span class="k">throw</span> <span class="nx">err</span> <span class="k">if</span> <span class="nx">err</span>
      <span class="nx">p</span> <span class="s2">&quot;#{code}&quot;</span>
      <span class="nv">name = </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span> <span class="nx">src</span><span class="p">,</span> <span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
      <span class="nv">dir  = </span><span class="nx">path</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">dirname</span><span class="p">(</span><span class="nx">src</span><span class="p">),</span> <span class="s2">&quot;#{name}.js&quot;</span><span class="p">)</span>
      <span class="nv">out  = </span><span class="nx">MacroScript</span><span class="p">.</span><span class="nx">compile</span> <span class="nx">code</span><span class="p">,</span> <span class="p">{</span><span class="nx">bare</span><span class="o">:</span><span class="kc">on</span><span class="p">}</span>
      <span class="nx">p</span> <span class="s2">&quot;#{out}&quot;</span>
      <span class="nx">fs</span><span class="p">.</span><span class="nx">writeFile</span> <span class="nx">dir</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nf">(err)-&gt;</span> <span class="k">if</span> <span class="nx">err</span> <span class="k">then</span> <span class="k">throw</span> <span class="nx">err</span> <span class="k">else</span> <span class="nx">p</span> <span class="s2">&quot;Success!&quot;</span>

<span class="nx">_</span><span class="p">.</span><span class="nx">extend</span> <span class="nb">window</span><span class="p">,</span> <span class="p">{</span><span class="nv">Macro: </span><span class="nx">Macro</span><span class="p">}</span> <span class="k">if</span> <span class="nb">window</span><span class="o">?</span>
<span class="nv">exports.Macro = </span><span class="nx">Macro</span> <span class="k">if</span> <span class="nx">exports</span><span class="o">?</span>
<span class="nx">exports</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">v</span> <span class="k">for</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="k">in</span> <span class="nx">Utils</span> <span class="k">if</span> <span class="nx">exports</span><span class="o">?</span></pre></div>             </td>           </tr>                               <tr id="section-34">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-34">&#182;</a>               </div>               <h1>Macros in Other Languages</h1>

<p>CoffeeScript has a very clean <a href="http://en.wikipedia.org/wiki/Abstract_Syntax_Tree">AST</a>.</p>

<p>You can get at the AST in <a href="http://parsetree.rubyforge.org/">Ruby</a> and
<a href="http://norvig.com/python-lisp.html">Python</a> pretty easily, though. If you
like macros and don't want to do without them in one of those languages,
I can't think offhand why something like this wouldn't work.</p>

<p>We use preprocessors on our SCSS to compile to CSS, and use
ad-hoc macros there.</p>

<p>We use generators in Rails.</p>

<p>We use a thousand templating languages to generate code all day long.</p>

<p>It is really so weird to add an abstraction that supports
<em>real</em> code generation? Even if it's implemented as a preprocessing step?</p>

<p>Seems worth exploring further.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                               <tr id="section-35">             <td class="docs">               <div class="pilwrap">                 <a class="pilcrow" href="#section-35">&#182;</a>               </div>               <h4>This One's for my homies ...</h4>

<p>Big shoutout to David Padbury for getting HackerNews thinking about this
stuff with his
<a href="http://blog.davidpadbury.com/2010/12/09/making-macros-in-coffeescript/">original blog post</a></p>

<p>Those were were C-style, substitution-based macros, not functions that allowed
arbitrary transformations on the AST -- but he used
AST to do them, and it was probably a repost on Hacker News
that got me wondering if real Lisp-style macros were a possibility.</p>             </td>             <td class="code">               <div class="highlight"><pre></pre></div>             </td>           </tr>                </tbody>     </table>   </div> </body> </html> 